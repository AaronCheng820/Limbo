<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Limbo: Limbo.Solvers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Limbo
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Limbo.Solvers </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Solvers_Introduction">Introduction</a></li>
<li class="level1"><a href="#Solvers_Examples">Examples</a><ul><li class="level2"><a href="#Solvers_Examples_MCF">Dual Min-Cost Flow Solvers</a></li>
<li class="level2"><a href="#Solvers_Csdp">Csdp Solver</a></li>
<li class="level2"><a href="#Solvers_Examples_GurobiApi">Gurobi API</a></li>
<li class="level2"><a href="#Solvers_Examples_All">All Examples</a></li>
</ul>
</li>
<li class="level1"><a href="#Solvers_References">References</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="Solvers_Introduction"></a>
Introduction</h1>
<p>Solvers and API for specialized problems, such as solving special linear programming problems with min-cost flow algorithms. It also wraps solvers like semidefinite programming solver <a href="https://projects.coin-or.org/Csdp" title="Csdp">Csdp</a> and convex optimization solver <a href="https://www.gurobi.com" title="Gurobi">Gurobi</a>.</p>
<h1><a class="anchor" id="Solvers_Examples"></a>
Examples</h1>
<h2><a class="anchor" id="Solvers_Examples_MCF"></a>
Dual Min-Cost Flow Solvers</h2>
<p>The analysis and background of using dual min-cost flow to solve linear programming problem can be found in the detailed description of class <a class="el" href="a00070.html">limbo::solvers::DualMinCostFlow</a> and <a class="el" href="a00154.html">limbo::solvers::lpmcf::LpDualMcf</a>.</p>
<p>See documented version: <a class="el" href="a00382.html">test/solvers/test_DualMinCostFlow.cpp</a> </p>
<div class="fragment"><div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00348.html" title="Solve a special case of linear programming with dual min-cost flow. A better implementation of LpDual...">limbo/solvers/DualMinCostFlow.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="a00382.html#a1db05c176455595f4e75e72ac6c8d627" title="test file API">test</a>(std::string <span class="keyword">const</span>&amp; filename, <span class="keywordtype">int</span> alg)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="a00149.html" title="model to describe an optimization problem">limbo::solvers::LinearModel&lt;int, int&gt;</a> model_type; </div>
<div class="line">    model_type optModel; </div>
<div class="line">    optModel.<a class="code" href="a00149.html#a3c13306727a10e63f45d1fd808c9c0b2" title="read lp format">read</a>(filename); </div>
<div class="line"></div>
<div class="line">    <span class="comment">// print problem </span></div>
<div class="line">    optModel.print(std::cout); </div>
<div class="line"></div>
<div class="line">    <span class="comment">// solve </span></div>
<div class="line">    <a class="code" href="a00161.html" title="A base class of min-cost flow solver.">limbo::solvers::MinCostFlowSolver&lt;int, int&gt;</a>* minCostFlowSolver = NULL; </div>
<div class="line">    <span class="keywordflow">switch</span> (alg)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> 0:</div>
<div class="line">            minCostFlowSolver = <span class="keyword">new</span> <a class="code" href="a00055.html" title="Cost scaling algorithm for min-cost flow.">limbo::solvers::CostScaling&lt;int, int&gt;</a>(); </div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> 1:</div>
<div class="line">            minCostFlowSolver = <span class="keyword">new</span> <a class="code" href="a00031.html" title="Capacity scaling algorithm for min-cost flow.">limbo::solvers::CapacityScaling&lt;int, int&gt;</a>(); </div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> 2:</div>
<div class="line">            minCostFlowSolver = <span class="keyword">new</span> <a class="code" href="a00172.html" title="Network simplex algorithm for min-cost flow.">limbo::solvers::NetworkSimplex&lt;int, int&gt;</a>(); </div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> 3:</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">            minCostFlowSolver = <span class="keyword">new</span> <a class="code" href="a00056.html" title="Cycle canceling algorithm for min-cost flow.">limbo::solvers::CycleCanceling&lt;int, int&gt;</a>(); </div>
<div class="line">            <span class="keywordflow">break</span>; </div>
<div class="line">    }</div>
<div class="line">    <a class="code" href="a00070.html" title="LP solved with min-cost flow. A better implementation of limbo::solvers::lpmcf::LpDualMcf.">limbo::solvers::DualMinCostFlow&lt;int, int&gt;</a> solver (&amp;optModel); </div>
<div class="line">    <a class="code" href="a00409.html#a500190a99a5762b6aa25aec1230479f0" title="Some enums used in solver.">limbo::solvers::SolverProperty</a> status = solver(minCostFlowSolver);</div>
<div class="line">    <span class="comment">//limbo::solvers::SolverProperty status = solver();</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Problem solved &quot;</span> &lt;&lt; <a class="code" href="a00409.html#ae31d5e04adc36b4526e8856acf4ae2cf" title="Convert limbo::solvers::SolverProperty to std::string.">limbo::solvers::toString</a>(status) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    <span class="keyword">delete</span> minCostFlowSolver;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// print solutions </span></div>
<div class="line">    optModel.printSolution(std::cout);</div>
<div class="line">    <span class="comment">// print problem </span></div>
<div class="line">    optModel.print(std::cout); </div>
<div class="line"></div>
<div class="line">    <span class="comment">// print graph with solution information </span></div>
<div class="line">    solver.printGraph(<span class="keyword">true</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="a00357.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (argc &gt; 1)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">int</span> alg = 0; </div>
<div class="line">        <span class="keywordflow">if</span> (argc &gt; 2)</div>
<div class="line">            alg = atoi(argv[2]);</div>
<div class="line">        <span class="comment">// test file API </span></div>
<div class="line">        <a class="code" href="a00382.html#a1db05c176455595f4e75e72ac6c8d627" title="test file API">test</a>(argv[1], alg);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;at least 1 argument required\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Compiling and running commands (assuming LIMBO_DIR, BOOST_DIR and LEMON_DIR are well defined). <a class="el" href="a00013.html">Limbo.Parsers.LpParser</a> is required for <a class="el" href="a00070.html">limbo::solvers::DualMinCostFlow</a> to read input files in .lp format. </p>
<pre class="fragment">g++ -o test_DualMinCostFlow test_DualMinCostFlow.cpp -I $LIMBO_DIR/include -I $BOOST_DIR/include -I $LEMON_DIR/include -L $LEMON_DIR/lib -lemon -L $LIMBO_DIR/lib -llpparser
# test dual min-cost flow for linear programming problem 
./test_DualMinCostFlow lpmcf/benchmarks/problem.lp
</pre><p>Output </p>
<pre class="fragment"># debug.lgf 
@nodes
label   supply  name    potential   
0   -4  R1  -2  
1   -5  L1  -5  
2   -5  R2  -2  
3   -1  L2  -2  
4   3   x2  -3  
5   6   x1  -7  
6   3   x3  -4  
7   3   additional  -7  
@arcs
        label   capacity_upper  cost    flow    
5   4   0   3   4   1   
5   1   1   3   2   2   
5   0   2   3   2   3   
4   1   3   3   1   0   
4   0   4   3   1   1   
4   3   5   3   1   1   
4   2   6   3   1   2   
6   3   7   3   2   0   
6   2   8   3   2   3   
0   7   9   3   10  0   
7   1   10  3   2   0   
7   1   11  3   2   3   
2   7   12  3   10  0   
3   7   13  3   10  0   
4   7   14  3   10  0   
5   7   15  3   10  0   
6   7   16  3   10  0   
</pre> <pre class="fragment">Minimize
2 R1 + -2 L1 + 1 R2 + -1 L2

Subject To
C0: 1 x2 + -1 x1 &gt;= 4
C1: -1 L1 + 1 x1 &gt;= -2
C2: 1 R1 + -1 x1 &gt;= 2
C3: -1 L1 + 1 x2 &gt;= -1
C4: 1 R1 + -1 x2 &gt;= 1
C5: -1 L2 + 1 x2 &gt;= -1
C6: 1 R2 + -1 x2 &gt;= 1
C7: -1 L2 + 1 x3 &gt;= -2
C8: 1 R2 + -1 x3 &gt;= 2
Bounds
R1 &gt;= -10
2 &lt;= L1 &lt;= 2
R2 &gt;= -10
L2 &gt;= -10
x2 &gt;= -10
x1 &gt;= -10
x3 &gt;= -10
Generals
R1
L1
R2
L2
x2
x1
x3
End

Problem solved OPTIMAL
# Objective 6
R1 5
L1 2
R2 5
L2 5
x2 4
x1 0
x3 3
</pre><h2><a class="anchor" id="Solvers_Csdp"></a>
Csdp Solver</h2>
<p>See documented version: <a class="el" href="a00288.html">limbo/algorithms/coloring/SDPColoringCsdp.h</a> </p>
<div class="fragment"><div class="line"></div>
<div class="line"><span class="preprocessor">#ifndef LIMBO_ALGORITHMS_COLORING_SDPCOLORINGCSDP</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define LIMBO_ALGORITHMS_COLORING_SDPCOLORINGCSDP</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00354.html" title="Check string is integer, floating point, number... Convert string to upper/lower cases.">limbo/string/String.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00281.html" title="Various graph simplification techniques for graph coloring. Some of them can also be used in other ap...">limbo/algorithms/coloring/GraphSimplification.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00280.html" title="base class for all graph coloring algorithms">limbo/algorithms/coloring/Coloring.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00278.html" title="graph coloring by backtracking">limbo/algorithms/coloring/BacktrackColoring.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00293.html" title="Implementation of the Multi-way FM partitioning algorithm.">limbo/algorithms/partition/FMMultiWay.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00296.html" title="A disjoint set structure and union-find utilities.">limbo/containers/DisjointSet.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// as the original csdp easy_sdp api is not very flexible to printlevel</span></div>
<div class="line"><span class="comment">// I made small modification to support that </span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00346.html" title="this file is a modified version of easysdp.c in Csdp package. Original version does not provide contr...">limbo/solvers/api/CsdpEasySdpApi.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>limbo </div>
<div class="line">{ </div>
<div class="line"><span class="keyword">namespace </span>algorithms </div>
<div class="line">{ </div>
<div class="line"><span class="keyword">namespace </span>coloring </div>
<div class="line">{</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GraphType&gt;</div>
<div class="line"><span class="keyword">class </span>SDPColoringCsdp : <span class="keyword">public</span> Coloring&lt;GraphType&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">typedef</span> Coloring&lt;GraphType&gt; base_type;</div>
<div class="line">        <span class="keyword">using</span> <span class="keyword">typename</span> base_type::graph_type;</div>
<div class="line">        <span class="keyword">using</span> <span class="keyword">typename</span> base_type::graph_vertex_type;</div>
<div class="line">        <span class="keyword">using</span> <span class="keyword">typename</span> base_type::graph_edge_type;</div>
<div class="line">        <span class="keyword">using</span> <span class="keyword">typename</span> base_type::vertex_iterator_type;</div>
<div class="line">        <span class="keyword">using</span> <span class="keyword">typename</span> base_type::edge_iterator_type;</div>
<div class="line">        <span class="keyword">using</span> <span class="keyword">typename</span> base_type::edge_weight_type;</div>
<div class="line">        <span class="keyword">using</span> <span class="keyword">typename</span> <a class="code" href="a00036.html#a7898d4a14f7ed7c4a37c2353e5330de2" title="number of colors">base_type::ColorNumType</a>;</div>
<div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> base_type::EdgeHashType edge_hash_type;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">struct </span>FMGainCalcType</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">typedef</span> edge_weight_type <a class="code" href="a00086.html#a5379e20a7b1351f3ae3c3f784bbe4acc" title="define edge_weight_type as value_type">value_type</a>;</div>
<div class="line">            graph_type <span class="keyword">const</span>&amp; <a class="code" href="a00086.html#a09b37946c9eb7b3a766a6290477129df" title="graph">graph</a>; </div>
<div class="line"></div>
<div class="line">            <a class="code" href="a00086.html#a9b2e88b7062c72382ec20498574640da">FMGainCalcType</a>(graph_type <span class="keyword">const</span>&amp; g) : <a class="code" href="a00086.html#a09b37946c9eb7b3a766a6290477129df" title="graph">graph</a>(g) {}</div>
<div class="line">            edge_weight_type <a class="code" href="a00086.html#a3bd09914804624d8115fa64a86862bee">operator()</a>(int32_t v, int8_t origp, int8_t newp, std::vector&lt;int8_t&gt; <span class="keyword">const</span>&amp; vPartition)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">            </span>{</div>
<div class="line">                <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::graph_traits&lt;graph_type&gt;::out_edge_iterator out_edge_iterator_type;</div>
<div class="line">                out_edge_iterator_type ei, eie; </div>
<div class="line">                <span class="comment">// if v is not partitioned, then any partition will have preassigned large gain </span></div>
<div class="line">                edge_weight_type gain = (origp &gt;= 0)? 0 : boost::num_edges(<a class="code" href="a00086.html#a09b37946c9eb7b3a766a6290477129df" title="graph">graph</a>)*boost::num_vertices(<a class="code" href="a00086.html#a09b37946c9eb7b3a766a6290477129df" title="graph">graph</a>);</div>
<div class="line">                <span class="keywordflow">for</span> (boost::tie(ei, eie) = boost::out_edges(v, <a class="code" href="a00086.html#a09b37946c9eb7b3a766a6290477129df" title="graph">graph</a>); ei != eie; ++ei)</div>
<div class="line">                {</div>
<div class="line">                    graph_vertex_type t = boost::target(*ei, <a class="code" href="a00086.html#a09b37946c9eb7b3a766a6290477129df" title="graph">graph</a>);</div>
<div class="line">                    int8_t pt = vPartition[t];</div>
<div class="line"><span class="preprocessor">#ifdef DEBUG_SDPCOLORING</span></div>
<div class="line"><span class="preprocessor"></span>                    assert((int32_t)t != v);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>                    <span class="comment">// skip unpartitioned vertex </span></div>
<div class="line">                    <span class="keywordflow">if</span> (pt &lt; 0) <span class="keywordflow">continue</span>;</div>
<div class="line">                    edge_weight_type w = boost::get(boost::edge_weight, <a class="code" href="a00086.html#a09b37946c9eb7b3a766a6290477129df" title="graph">graph</a>, *ei);</div>
<div class="line">                    <span class="comment">// assume origp != newp, pt &gt;= 0 </span></div>
<div class="line">                    gain += (pt == newp)? -w : (pt == origp)? w : 0;</div>
<div class="line">                    <span class="comment">//gain += w * ((vPartition[t] == origp &amp;&amp; origp &gt;= 0) - (vPartition[t] == newp));</span></div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">return</span> gain;</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line">        <a class="code" href="a00223.html#a40ce32d73c7ca625571485f7ac599ebd">SDPColoringCsdp</a>(graph_type <span class="keyword">const</span>&amp; g); </div>
<div class="line">        <span class="keyword">virtual</span> <a class="code" href="a00223.html#a8e736075fb63b3c66e54479fc0c9051d" title="destructor">~SDPColoringCsdp</a>() {}</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">void</span> <a class="code" href="a00223.html#a7d40dbcbc4f154c29e83da036a16f7c8">write_sdp_sol</a>(std::string <span class="keyword">const</span>&amp; filename, <span class="keyword">struct</span> blockmatrix <span class="keyword">const</span>&amp; X) <span class="keyword">const</span>; </div>
<div class="line">        <span class="keywordtype">void</span> <a class="code" href="a00223.html#a0f936c84a5891ba2e484b658467c52d4">print_blockrec</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* label, blockrec <span class="keyword">const</span>&amp; block) <span class="keyword">const</span>; </div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="a00223.html#abf08702f30817fd991e6d72c42f9bf35">coloring</a>();</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">void</span> <a class="code" href="a00223.html#a1eaa9c0f465fcb7286283949b032825a">construct_objectve_blockrec</a>(blockmatrix&amp; C, int32_t blocknum, int32_t blocksize, blockcat blockcategory) <span class="keyword">const</span>; </div>
<div class="line">        <span class="keyword">struct </span>sparseblock* <a class="code" href="a00223.html#a0497a0792e24f019f0046465e01b26ca">construct_constraint_sparseblock</a>(int32_t blocknum, int32_t blocksize, int32_t constraintnum, int32_t entrynum) <span class="keyword">const</span>; </div>
<div class="line">        <span class="keywordtype">void</span> <a class="code" href="a00223.html#a710d00b7c64c6569092efd279c0db8a3">set_sparseblock_entry</a>(<span class="keyword">struct</span> sparseblock&amp; block, int32_t entryid, int32_t i, int32_t j, <span class="keywordtype">double</span> value) <span class="keyword">const</span>; </div>
<div class="line">        <span class="keywordtype">void</span> <a class="code" href="a00223.html#a5f6e469a374511665de91ddf6189b407">round_sol</a>(<span class="keyword">struct</span> blockmatrix <span class="keyword">const</span>&amp; X);</div>
<div class="line">        <span class="keywordtype">void</span> <a class="code" href="a00223.html#a65478f75c8e81a68f9144921def30f6d">coloring_merged_graph</a>(graph_type <span class="keyword">const</span>&amp; mg, std::vector&lt;int8_t&gt;&amp; vMColor) <span class="keyword">const</span>;</div>
<div class="line">        <span class="keywordtype">void</span> <a class="code" href="a00223.html#a9abaaacaab0c9228e6bf600f19d1f50a">coloring_algos</a>(graph_type <span class="keyword">const</span>&amp; g, std::vector&lt;int8_t&gt;&amp; vColor) <span class="keyword">const</span>;</div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="a00223.html#af4e0e23c6f43bd6be46957477678c0a9">coloring_by_backtrack</a>(graph_type <span class="keyword">const</span>&amp; mg, std::vector&lt;int8_t&gt;&amp; vColor) <span class="keyword">const</span>;</div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="a00223.html#ac3b82d503b968648fc16713a758ea782">coloring_by_FM</a>(graph_type <span class="keyword">const</span>&amp; mg, std::vector&lt;int8_t&gt;&amp; vColor) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">double</span> <a class="code" href="a00223.html#a463f43457f934433a47fcc2515dde961" title="if SDP solution x &lt; m_rounding_lb, take x as -0.5">m_rounding_lb</a>; </div>
<div class="line">        <span class="keywordtype">double</span> <a class="code" href="a00223.html#a58093dac5b4e8b5dea34d2c5b9931587" title="if SDP solution x &gt; m_rounding_ub, take x as 1.0">m_rounding_ub</a>; </div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">static</span> uint32_t <a class="code" href="a00223.html#a7adbd946dc628ad653df7d319416729b" title="maximum number of graph size that limbo::algorithms::coloring::BacktrackColoring can handle...">max_backtrack_num_vertices</a> = 7; </div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GraphType&gt;</div>
<div class="line"><a class="code" href="a00223.html#a40ce32d73c7ca625571485f7ac599ebd">SDPColoringCsdp&lt;GraphType&gt;::SDPColoringCsdp</a>(SDPColoringCsdp&lt;GraphType&gt;::graph_type <span class="keyword">const</span>&amp; g) </div>
<div class="line">    : base_type(g)</div>
<div class="line">{</div>
<div class="line">    m_rounding_lb = -0.4;</div>
<div class="line">    m_rounding_ub = 0.9;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GraphType&gt;</div>
<div class="line"><span class="keywordtype">double</span> SDPColoringCsdp&lt;GraphType&gt;::coloring()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Since Csdp is written in C, the api here is also in C </span></div>
<div class="line">    <span class="comment">// Please refer to the documation of Csdp for different notations </span></div>
<div class="line">    <span class="comment">// basically, X is primal variables, C, b, constraints and pobj are all for primal </span></div>
<div class="line">    <span class="comment">// y, Z, and dobj are for dual problem </span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Csdp has very complex storage structure for matrix </span></div>
<div class="line">    <span class="comment">// I still do not have a full understanding about the block concept, especially blocks.blocksize </span></div>
<div class="line">    <span class="comment">// with some reverse engineering, for the coloring problem here, matrices in C, b, and constraints mainly consists of 2 blocks </span></div>
<div class="line">    <span class="comment">// the first block is for vertex variables, and the second block is for slack variables introduced to resolve &#39;&gt;=&#39; operators in the constraints</span></div>
<div class="line"></div>
<div class="line">    <a class="code" href="a00341.html#aa5d7c58f57e3700b0de23ae54972bbca" title="assertion with message">assert_msg</a>(!this-&gt;has_precolored(), <span class="stringliteral">&quot;SDP coloring does not support precolored layout yet&quot;</span>);</div>
<div class="line">    <span class="comment">// The problem and solution data.</span></div>
<div class="line">    <span class="keyword">struct </span>blockmatrix C; <span class="comment">// objective matrix </span></div>
<div class="line">    <span class="keywordtype">double</span> *b; <span class="comment">// right hand side of constraints</span></div>
<div class="line">    <span class="keyword">struct </span>constraintmatrix *constraints; <span class="comment">// constraint matrices</span></div>
<div class="line">    <span class="comment">// Storage for the initial and final solutions.</span></div>
<div class="line">    <span class="keyword">struct </span>blockmatrix X,Z;</div>
<div class="line">    <span class="keywordtype">double</span> *y;</div>
<div class="line">    <span class="keywordtype">double</span> pobj,dobj;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// iterators used to traverse through the graph </span></div>
<div class="line">    vertex_iterator_type vi, vie; </div>
<div class="line">    edge_iterator_type ei, eie; </div>
<div class="line">    <span class="comment">// compute total number of vertices and edges </span></div>
<div class="line">    uint32_t num_vertices = boost::num_vertices(this-&gt;m_graph);</div>
<div class="line">    uint32_t num_edges = boost::num_edges(this-&gt;m_graph);</div>
<div class="line">    <span class="comment">// compute total number of conflict edges and stitch edges </span></div>
<div class="line">    uint32_t num_conflict_edges = 0;</div>
<div class="line">    uint32_t num_stitch_edges = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (boost::tie(ei, eie) = boost::edges(this-&gt;m_graph); ei != eie; ++ei)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (this-&gt;edge_weight(*ei) &gt;= 0) <span class="comment">// conflict edge </span></div>
<div class="line">            num_conflict_edges += 1;</div>
<div class="line">        <span class="keywordflow">else</span> <span class="comment">// stitch edge </span></div>
<div class="line">            num_stitch_edges += 1;</div>
<div class="line">    }</div>
<div class="line">    <a class="code" href="a00341.html#aa5d7c58f57e3700b0de23ae54972bbca" title="assertion with message">assert_msg</a>(num_edges &gt; 0 &amp;&amp; num_conflict_edges &gt; 0, <span class="stringliteral">&quot;no edges or conflict edges found, no need to solve SDP&quot;</span>);</div>
<div class="line">    <span class="comment">// compute total number of variables and constraints</span></div>
<div class="line">    uint32_t num_variables = num_vertices+num_conflict_edges;</div>
<div class="line">    uint32_t num_constraints = num_conflict_edges+num_vertices;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// setup blockmatrix C </span></div>
<div class="line">    C.nblocks = 2;</div>
<div class="line">    C.blocks = (<span class="keyword">struct </span>blockrec *)malloc((C.nblocks+1)*<span class="keyword">sizeof</span>(<span class="keyword">struct </span>blockrec));</div>
<div class="line">    <a class="code" href="a00341.html#aa5d7c58f57e3700b0de23ae54972bbca" title="assertion with message">assert_msg</a>(C.blocks, <span class="stringliteral">&quot;Couldn&#39;t allocate storage for C&quot;</span>);</div>
<div class="line">    <span class="comment">// C.blocks[0] is not used according to the example of Csdp</span></div>
<div class="line">    <span class="comment">// block 1 for vertex variables </span></div>
<div class="line">    construct_objectve_blockrec(C, 1, num_vertices, MATRIX);</div>
<div class="line">    <span class="keywordflow">for</span> (boost::tie(ei, eie) = boost::edges(this-&gt;m_graph); ei != eie; ++ei)</div>
<div class="line">    {</div>
<div class="line">        graph_vertex_type s = boost::source(*ei, this-&gt;m_graph);</div>
<div class="line">        graph_vertex_type t = boost::target(*ei, this-&gt;m_graph);</div>
<div class="line">        <span class="comment">// 1 for conflict edge, -alpha for stitch edge </span></div>
<div class="line">        <span class="comment">// add unary negative operator, because Csdp solves maximization problem </span></div>
<div class="line">        <span class="comment">// but we are solving minimization problem </span></div>
<div class="line">        edge_weight_type alpha = (this-&gt;edge_weight(*ei) &gt;= 0)? -1 : this-&gt;stitch_weight();</div>
<div class="line">        <span class="comment">// variable starts from 1 instead of 0 in Csdp</span></div>
<div class="line">        s += 1; t += 1;</div>
<div class="line">        int32_t idx1 = ijtok(s,t,C.blocks[1].blocksize);</div>
<div class="line">        int32_t idx2 = ijtok(t,s,C.blocks[1].blocksize);</div>
<div class="line">        C.blocks[1].data.mat[idx1] = alpha; </div>
<div class="line">        C.blocks[1].data.mat[idx2] = alpha;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// block 2 for slack variables </span></div>
<div class="line">    <span class="comment">// this block is all 0s, so we use diagonal format to represent  </span></div>
<div class="line">    construct_objectve_blockrec(C, 2, num_conflict_edges, DIAG);</div>
<div class="line"><span class="preprocessor">#ifdef DEBUG_SDPCOLORING</span></div>
<div class="line"><span class="preprocessor"></span>    print_blockrec(<span class="stringliteral">&quot;C.blocks[1].data.mat&quot;</span>, C.blocks[1]);</div>
<div class="line">    print_blockrec(<span class="stringliteral">&quot;C.blocks[2].data.vec&quot;</span>, C.blocks[2]);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="comment">// setup right hand side of constraints b</span></div>
<div class="line">    <span class="comment">// the order is first for conflict edges and then for vertices  </span></div>
<div class="line">    <span class="comment">// the order matters for constraint matrices </span></div>
<div class="line">    b = (<span class="keywordtype">double</span> *)malloc((num_constraints+1)*<span class="keyword">sizeof</span>(double));</div>
<div class="line">    <a class="code" href="a00341.html#aa5d7c58f57e3700b0de23ae54972bbca" title="assertion with message">assert_msg</a>(b, <span class="stringliteral">&quot;Failed to allocate storage for right hand side of constraints b&quot;</span>);</div>
<div class="line">    <span class="comment">// -1/(k-1) according to Bei Yu&#39;s DAC2014 paper</span></div>
<div class="line">    <span class="comment">// consider in the constraints, xij+xji &gt;= beta, so beta should be -2/(k-1)</span></div>
<div class="line">    <span class="keywordtype">double</span> beta = -2.0/(this-&gt;color_num()-1.0); <span class="comment">// right hand side of constraints for conflict edges </span></div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 1, ie = num_constraints+1; i != ie; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (i &lt;= num_conflict_edges) <span class="comment">// slack for each conflict edge, xij &gt;= -0.5</span></div>
<div class="line">            b[i] = beta;</div>
<div class="line">        <span class="keywordflow">else</span> <span class="comment">// slack for each vertex, xii = 1</span></div>
<div class="line">            b[i] = 1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// setup constraint matrix constraints</span></div>
<div class="line">    <span class="comment">// the order should be the same as right hand side b </span></div>
<div class="line">    constraints=(<span class="keyword">struct </span>constraintmatrix *)malloc((num_constraints+1)*<span class="keyword">sizeof</span>(<span class="keyword">struct </span>constraintmatrix));</div>
<div class="line">    <a class="code" href="a00341.html#aa5d7c58f57e3700b0de23ae54972bbca" title="assertion with message">assert_msg</a>(constraints, <span class="stringliteral">&quot;Failed to allocate storage for constraints&quot;</span>);</div>
<div class="line">    <span class="comment">// for conflict edges, xij </span></div>
<div class="line">    uint32_t cnt = 1;</div>
<div class="line">    <span class="keywordflow">for</span> (boost::tie(ei, eie) = boost::edges(this-&gt;m_graph); ei != eie; ++ei)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (this-&gt;edge_weight(*ei) &gt;= 0) <span class="comment">// conflict edge </span></div>
<div class="line">        {</div>
<div class="line">            graph_vertex_type s = boost::source(*ei, this-&gt;m_graph);</div>
<div class="line">            graph_vertex_type t = boost::target(*ei, this-&gt;m_graph);</div>
<div class="line">            <span class="keywordflow">if</span> (s &gt; t) <span class="comment">// due to symmetry, only need to create constraint matrices for upper-matrix </span></div>
<div class="line">                std::swap(s, t);</div>
<div class="line">            <span class="comment">// variable starts from 1 instead of 0 in Csdp</span></div>
<div class="line">            s += 1; t += 1;</div>
<div class="line">            <span class="keyword">struct </span>constraintmatrix&amp; constr = constraints[cnt];</div>
<div class="line">            <span class="comment">// Terminate the linked list with a NULL pointer.</span></div>
<div class="line">            constr.blocks = NULL;</div>
<div class="line">            <span class="comment">// inverse order to initialize blocks, because linked list will reverse the order </span></div>
<div class="line">            <span class="comment">// first set block 2 for diagonal values and then block 1 for upper-matrix values  </span></div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t i = 2; i != 0; --i)</div>
<div class="line">            {</div>
<div class="line">                <span class="keyword">struct </span>sparseblock* blockptr;</div>
<div class="line">                <span class="keywordflow">if</span> (i == 1) <span class="comment">// block 1, vertex variables  </span></div>
<div class="line">                {</div>
<div class="line">                    blockptr = construct_constraint_sparseblock(i, num_vertices, cnt, 1);</div>
<div class="line">                    set_sparseblock_entry(*blockptr, 1, s, t, 1);</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span> <span class="comment">// block 2, slack variables </span></div>
<div class="line">                {</div>
<div class="line">                    blockptr = construct_constraint_sparseblock(i, num_conflict_edges, cnt, 1);</div>
<div class="line">                    set_sparseblock_entry(*blockptr, 1, cnt, cnt, -1);</div>
<div class="line">                }</div>
<div class="line">                <span class="comment">// insert block to linked list </span></div>
<div class="line">                blockptr-&gt;next = constr.blocks;</div>
<div class="line">                constr.blocks = blockptr;</div>
<div class="line">            }</div>
<div class="line">            ++cnt;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// for vertices, xii </span></div>
<div class="line">    <span class="keywordflow">for</span> (boost::tie(vi, vie) = boost::vertices(this-&gt;m_graph); vi != vie; ++vi)</div>
<div class="line">    {</div>
<div class="line">        graph_vertex_type v = *vi;</div>
<div class="line">        v += 1;</div>
<div class="line">        <span class="keyword">struct </span>constraintmatrix&amp; constr = constraints[cnt];</div>
<div class="line">        <span class="comment">// Terminate the linked list with a NULL pointer.</span></div>
<div class="line">        constr.blocks = NULL;</div>
<div class="line">        <span class="keyword">struct </span>sparseblock* blockptr = construct_constraint_sparseblock(1, num_vertices, cnt, 1);</div>
<div class="line">        set_sparseblock_entry(*blockptr, 1, v, v, 1);</div>
<div class="line">        <span class="comment">// insert block to linked list </span></div>
<div class="line">        blockptr-&gt;next = constr.blocks;</div>
<div class="line">        constr.blocks = blockptr;</div>
<div class="line">        ++cnt;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef DEBUG_SDPCOLORING</span></div>
<div class="line"><span class="preprocessor"></span>    write_prob((<span class="keywordtype">char</span>*)<span class="stringliteral">&quot;problem.sdpa&quot;</span>, num_variables, num_constraints, C, b, constraints);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="comment">// after all configuration ready </span></div>
<div class="line">    <span class="comment">// start solving sdp </span></div>
<div class="line">    <span class="comment">// set initial solution </span></div>
<div class="line">    initsoln(num_variables, num_constraints, C, b, constraints, &amp;X, &amp;y, &amp;Z);</div>
<div class="line">    <span class="comment">// use default params </span></div>
<div class="line">    <span class="comment">// only set printlevel to zero </span></div>
<div class="line">    <span class="keyword">struct </span>paramstruc params; </div>
<div class="line">    <span class="keywordtype">int</span> printlevel;</div>
<div class="line">    initparams(&amp;params, &amp;printlevel);</div>
<div class="line"><span class="comment">//#ifndef DEBUG_SDPCOLORING</span></div>
<div class="line">    printlevel = 0;</div>
<div class="line"><span class="comment">//#endif</span></div>
<div class="line">    <span class="comment">// A return code for the call to easy_sdp().</span></div>
<div class="line">    <span class="comment">// solve sdp </span></div>
<div class="line">    <span class="comment">// objective value is (dobj+pobj)/2</span></div>
<div class="line">    <span class="comment">//int ret = easy_sdp(num_variables, num_constraints, C, b, constraints, 0.0, &amp;X, &amp;y, &amp;Z, &amp;pobj, &amp;dobj);</span></div>
<div class="line">    <span class="keywordtype">int</span> ret = limbo::solvers::easy_sdp_ext&lt;int&gt;(num_variables, num_constraints, C, b, constraints, 0.0, &amp;X, &amp;y, &amp;Z, &amp;pobj, &amp;dobj, params, printlevel);</div>
<div class="line">    <a class="code" href="a00341.html#aa5d7c58f57e3700b0de23ae54972bbca" title="assertion with message">assert_msg</a>(ret == 0, <span class="stringliteral">&quot;SDP failed&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// round result to get colors </span></div>
<div class="line">    round_sol(X);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Free storage allocated for the problem and return.</span></div>
<div class="line">    free_prob(num_variables, num_constraints, C, b, constraints, X, y, Z);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef DEBUG_LPCOLORING</span></div>
<div class="line"><span class="preprocessor"></span>    this-&gt;<a class="code" href="a00402.html#afd0e9377c1211cdbe9ef63a022a9ed71" title="write graph to graphviz format and convert to pdf. Although Boost.Graph has write_graphviz component...">write_graph</a>(<span class="stringliteral">&quot;final_output&quot;</span>);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">// return objective value </span></div>
<div class="line">    <span class="comment">//return (dobj+pobj)/2;</span></div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;calc_cost(this-&gt;m_vColor);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GraphType&gt;</div>
<div class="line"><span class="keywordtype">void</span> SDPColoringCsdp&lt;GraphType&gt;::construct_objectve_blockrec(blockmatrix&amp; C, int32_t blocknum, int32_t blocksize, blockcat blockcategory)<span class="keyword"> const </span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keyword">struct </span>blockrec&amp; cblock = C.blocks[blocknum];</div>
<div class="line">    cblock.blocksize = blocksize;</div>
<div class="line">    cblock.blockcategory = blockcategory;</div>
<div class="line">    <span class="keywordflow">if</span> (blockcategory == MATRIX)</div>
<div class="line">    {</div>
<div class="line">        cblock.data.mat = (<span class="keywordtype">double</span> *)malloc(blocksize*blocksize*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div>
<div class="line">        <a class="code" href="a00341.html#aa5d7c58f57e3700b0de23ae54972bbca" title="assertion with message">assert_msg</a>(cblock.data.mat, <span class="stringliteral">&quot;Couldn&#39;t allocate storage for cblock.data.mat&quot;</span>);</div>
<div class="line">        <span class="comment">// initialize to all 0s</span></div>
<div class="line">        std::fill(cblock.data.mat, cblock.data.mat+blocksize*blocksize, 0); </div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (blockcategory == DIAG)</div>
<div class="line">    {</div>
<div class="line">        cblock.data.vec = (<span class="keywordtype">double</span> *)malloc((blocksize+1)*<span class="keyword">sizeof</span>(double));</div>
<div class="line">        <a class="code" href="a00341.html#aa5d7c58f57e3700b0de23ae54972bbca" title="assertion with message">assert_msg</a>(cblock.data.vec, <span class="stringliteral">&quot;Couldn&#39;t allocate storage for cblock.data.vec&quot;</span>);</div>
<div class="line">        <span class="comment">// initialize to all 0s</span></div>
<div class="line">        std::fill(cblock.data.vec, cblock.data.vec+blocksize+1, 0); </div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GraphType&gt;</div>
<div class="line"><span class="keyword">struct </span>sparseblock* SDPColoringCsdp&lt;GraphType&gt;::construct_constraint_sparseblock(int32_t blocknum, int32_t blocksize, int32_t constraintnum, int32_t entrynum)<span class="keyword"> const </span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keyword">struct </span>sparseblock* blockptr = (<span class="keyword">struct </span>sparseblock *)malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sparseblock));</div>
<div class="line">    <a class="code" href="a00341.html#aa5d7c58f57e3700b0de23ae54972bbca" title="assertion with message">assert_msg</a>(blockptr, <span class="stringliteral">&quot;Allocation of constraint block failed for blockptr&quot;</span>);</div>
<div class="line">    blockptr-&gt;blocknum = blocknum;</div>
<div class="line">    blockptr-&gt;blocksize = blocksize;</div>
<div class="line">    blockptr-&gt;constraintnum = constraintnum;</div>
<div class="line">    blockptr-&gt;next = NULL;</div>
<div class="line">    blockptr-&gt;nextbyblock = NULL;</div>
<div class="line">    blockptr-&gt;entries = (<span class="keywordtype">double</span> *) malloc((entrynum+1)*<span class="keyword">sizeof</span>(double));</div>
<div class="line">    <a class="code" href="a00341.html#aa5d7c58f57e3700b0de23ae54972bbca" title="assertion with message">assert_msg</a>(blockptr-&gt;entries, <span class="stringliteral">&quot;Allocation of constraint block failed for blockptr-&gt;entries&quot;</span>);</div>
<div class="line">    blockptr-&gt;iindices = (<span class="keywordtype">int</span> *) malloc((entrynum+1)*<span class="keyword">sizeof</span>(int));</div>
<div class="line">    <a class="code" href="a00341.html#aa5d7c58f57e3700b0de23ae54972bbca" title="assertion with message">assert_msg</a>(blockptr-&gt;iindices, <span class="stringliteral">&quot;Allocation of constraint block failed for blockptr-&gt;iindices&quot;</span>);</div>
<div class="line">    blockptr-&gt;jindices = (<span class="keywordtype">int</span> *) malloc((entrynum+1)*<span class="keyword">sizeof</span>(int));</div>
<div class="line">    <a class="code" href="a00341.html#aa5d7c58f57e3700b0de23ae54972bbca" title="assertion with message">assert_msg</a>(blockptr-&gt;jindices, <span class="stringliteral">&quot;Allocation of constraint block failed for blockptr-&gt;jindices&quot;</span>);</div>
<div class="line">    blockptr-&gt;numentries = entrynum;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> blockptr;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GraphType&gt;</div>
<div class="line"><span class="keywordtype">void</span> SDPColoringCsdp&lt;GraphType&gt;::set_sparseblock_entry(<span class="keyword">struct</span> sparseblock&amp; block, int32_t entryid, int32_t i, int32_t j, <span class="keywordtype">double</span> value)<span class="keyword"> const </span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    block.iindices[entryid] = i;</div>
<div class="line">    block.jindices[entryid] = j;</div>
<div class="line">    block.entries[entryid] = value;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GraphType&gt;</div>
<div class="line"><span class="keywordtype">void</span> SDPColoringCsdp&lt;GraphType&gt;::round_sol(<span class="keyword">struct</span> blockmatrix <span class="keyword">const</span>&amp; X)</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#ifdef DEBUG_SDPCOLORING</span></div>
<div class="line"><span class="preprocessor"></span>    write_sdp_sol(<span class="stringliteral">&quot;problem.sol&quot;</span>, X);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">// merge vertices with SDP solution with disjoint set </span></div>
<div class="line">    std::vector&lt;graph_vertex_type&gt; vParent (boost::num_vertices(this-&gt;m_graph));</div>
<div class="line">    std::vector&lt;uint32_t&gt; vRank (vParent.size());</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="a00061.html" title="simply used for scope control">limbo::containers::DisjointSet</a> disjoint_set_type;</div>
<div class="line">    disjoint_set_type::SubsetHelper&lt;graph_vertex_type, uint32_t&gt; gp (vParent, vRank);</div>
<div class="line">    <span class="comment">// check SDP solution in X </span></div>
<div class="line">    <span class="comment">// we are only interested in block 1 </span></div>
<div class="line">    <span class="keyword">struct </span>blockrec const&amp; block = X.blocks[1];</div>
<div class="line">    <a class="code" href="a00341.html#aa5d7c58f57e3700b0de23ae54972bbca" title="assertion with message">assert_msg</a>(block.blockcategory == MATRIX, <span class="stringliteral">&quot;mismatch of block category&quot;</span>);</div>
<div class="line">    <span class="keywordflow">for</span> (int32_t i = 1; i &lt;= block.blocksize; ++i)</div>
<div class="line">        <span class="keywordflow">for</span> (int32_t j = i+1; j &lt;= block.blocksize; ++j)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">double</span> ent = block.data.mat[ijtok(i, j, block.blocksize)];</div>
<div class="line">            <span class="keywordflow">if</span> (ent &gt; m_rounding_ub) <span class="comment">// merge vertices if SDP solution rounded to 1.0</span></div>
<div class="line">                disjoint_set_type::union_set(gp, i-1, j-1); <span class="comment">// Csdp array starts from 1 instead of 0</span></div>
<div class="line">        }</div>
<div class="line">    <span class="comment">// construct merged graph </span></div>
<div class="line">    <span class="comment">// for vertices in merged graph </span></div>
<div class="line">    std::vector&lt;graph_vertex_type&gt; vG2MG (vParent.size(), <a class="code" href="a00401.html#a70f11c16058445049de838e5805c9652" title="get max of an array">std::numeric_limits&lt;graph_vertex_type&gt;::max</a>()); <span class="comment">// mapping from graph to merged graph</span></div>
<div class="line">    uint32_t mg_count = 0; <span class="comment">// count number of vertices in merged graph </span></div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0, ie = vParent.size(); i != ie; ++i) <span class="comment">// check subset elements and compute mg_count</span></div>
<div class="line">        <span class="keywordflow">if</span> (vParent[i] == i)</div>
<div class="line">            vG2MG[i] = mg_count++;</div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0, ie = vParent.size(); i != ie; ++i) <span class="comment">// check other elements </span></div>
<div class="line">        <span class="keywordflow">if</span> (vParent[i] != i)</div>
<div class="line">            vG2MG[i] = vG2MG.at(disjoint_set_type::find_set(gp, i));</div>
<div class="line"><span class="preprocessor">#ifdef DEBUG_SDPCOLORING</span></div>
<div class="line"><span class="preprocessor"></span>    assert(mg_count == disjoint_set_type::count_sets(gp));</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>    graph_type mg (mg_count); <span class="comment">// merged graph </span></div>
<div class="line">    <span class="comment">// for edges in merged graph </span></div>
<div class="line">    edge_iterator_type ei, eie; </div>
<div class="line">    <span class="keywordflow">for</span> (boost::tie(ei, eie) = boost::edges(this-&gt;m_graph); ei != eie; ++ei)</div>
<div class="line">    {</div>
<div class="line">        graph_edge_type <span class="keyword">const</span>&amp; e = *ei;</div>
<div class="line">        graph_vertex_type s = boost::source(e, this-&gt;m_graph);</div>
<div class="line">        graph_vertex_type t = boost::target(e, this-&gt;m_graph);</div>
<div class="line">        graph_vertex_type ms = vG2MG.at(s);</div>
<div class="line">        graph_vertex_type mt = vG2MG.at(t);</div>
<div class="line">        std::pair&lt;graph_edge_type, bool&gt; me = boost::edge(ms, mt, mg);</div>
<div class="line">        <span class="comment">// need to consider if this setting is still reasonable when stitch is on </span></div>
<div class="line">        edge_weight_type w = (this-&gt;edge_weight(e) &gt;= 0)? 1 : -this-&gt;stitch_weight();</div>
<div class="line">        <span class="keywordflow">if</span> (me.second) <span class="comment">// already exist, update weight </span></div>
<div class="line">            w += boost::get(boost::edge_weight, mg, me.first);</div>
<div class="line">        <span class="keywordflow">else</span> <span class="comment">// not exist, add edge </span></div>
<div class="line">            me = boost::add_edge(ms, mt, mg);</div>
<div class="line">        boost::put(boost::edge_weight, mg, me.first, w);</div>
<div class="line"><span class="preprocessor">#ifdef DEBUG_SDPCOLORING</span></div>
<div class="line"><span class="preprocessor"></span>        assert(boost::get(boost::edge_weight, mg, me.first) != 0);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>    }</div>
<div class="line"><span class="preprocessor">#ifdef DEBUG_SDPCOLORING</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">//this-&gt;print_edge_weight(this-&gt;m_graph);</span></div>
<div class="line">    <span class="comment">//this-&gt;check_edge_weight(this-&gt;m_graph, this-&gt;stitch_weight()/10, 4);</span></div>
<div class="line">    <span class="comment">//this-&gt;print_edge_weight(mg);</span></div>
<div class="line">    this-&gt;check_edge_weight(mg, this-&gt;stitch_weight()/10, boost::num_edges(this-&gt;m_graph));</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">// coloring for merged graph </span></div>
<div class="line">    std::vector&lt;int8_t&gt; vMColor (mg_count, -1); <span class="comment">// coloring solution for merged graph </span></div>
<div class="line">    coloring_merged_graph(mg, vMColor);</div>
<div class="line">    <span class="comment">// apply coloring solution from merged graph to graph </span></div>
<div class="line">    <span class="comment">// first, map colors to subsets </span></div>
<div class="line">    vertex_iterator_type vi, vie; </div>
<div class="line">    <span class="keywordflow">for</span> (boost::tie(vi, vie) = boost::vertices(this-&gt;m_graph); vi != vie; ++vi)</div>
<div class="line">    {</div>
<div class="line">        graph_vertex_type v = *vi;</div>
<div class="line">        this-&gt;m_vColor[v] = vMColor.at(vG2MG.at(v));</div>
<div class="line"><span class="preprocessor">#ifdef DEBUG_SDPCOLORING</span></div>
<div class="line"><span class="preprocessor"></span>        assert(this-&gt;m_vColor[v] &gt;= 0 &amp;&amp; this-&gt;m_vColor[v] &lt; this-&gt;color_num());</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GraphType&gt;</div>
<div class="line"><span class="keywordtype">void</span> SDPColoringCsdp&lt;GraphType&gt;::coloring_merged_graph(graph_type <span class="keyword">const</span>&amp; mg, std::vector&lt;int8_t&gt;&amp; vMColor)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    uint32_t num_vertices = boost::num_vertices(mg);</div>
<div class="line">    <span class="comment">// if small number of vertices or no vertex merged, no need to simplify graph </span></div>
<div class="line">    <span class="keywordflow">if</span> (num_vertices &lt;= max_backtrack_num_vertices || num_vertices == boost::num_vertices(this-&gt;m_graph)) </div>
<div class="line">        coloring_algos(mg, vMColor);</div>
<div class="line">    <span class="keywordflow">else</span> </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// simplify merged graph </span></div>
<div class="line">        <span class="keyword">typedef</span> GraphSimplification&lt;graph_type&gt; graph_simplification_type;</div>
<div class="line">        graph_simplification_type gs (mg, this-&gt;color_num());</div>
<div class="line">        gs.simplify(graph_simplification_type::HIDE_SMALL_DEGREE);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// in order to recover color from articulation points </span></div>
<div class="line">        <span class="comment">// we have to record all components and mappings </span></div>
<div class="line">        <span class="comment">// but graph is not necessary </span></div>
<div class="line">        std::vector&lt;std::vector&lt;int8_t&gt; &gt; mSubColor (gs.num_component());</div>
<div class="line">        std::vector&lt;std::vector&lt;graph_vertex_type&gt; &gt; mSimpl2Orig (gs.num_component());</div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t sub_comp_id = 0; sub_comp_id &lt; gs.num_component(); ++sub_comp_id)</div>
<div class="line">        {</div>
<div class="line">            graph_type sg;</div>
<div class="line">            std::vector&lt;int8_t&gt;&amp; vSubColor = mSubColor[sub_comp_id];</div>
<div class="line">            std::vector&lt;graph_vertex_type&gt;&amp; vSimpl2Orig = mSimpl2Orig[sub_comp_id];</div>
<div class="line"></div>
<div class="line">            gs.simplified_graph_component(sub_comp_id, sg, vSimpl2Orig);</div>
<div class="line"></div>
<div class="line">            vSubColor.assign(boost::num_vertices(sg), -1);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef DEBUG_SDPCOLORING</span></div>
<div class="line"><span class="preprocessor"></span>            this-&gt;<a class="code" href="a00402.html#afd0e9377c1211cdbe9ef63a022a9ed71" title="write graph to graphviz format and convert to pdf. Although Boost.Graph has write_graphviz component...">write_graph</a>(<span class="stringliteral">&quot;initial_merged_graph&quot;</span>, sg, vSubColor);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>            <span class="comment">// solve coloring </span></div>
<div class="line">            coloring_algos(sg, vSubColor);</div>
<div class="line"><span class="preprocessor">#ifdef DEBUG_SDPCOLORING</span></div>
<div class="line"><span class="preprocessor"></span>            this-&gt;<a class="code" href="a00402.html#afd0e9377c1211cdbe9ef63a022a9ed71" title="write graph to graphviz format and convert to pdf. Although Boost.Graph has write_graphviz component...">write_graph</a>(<span class="stringliteral">&quot;final_merged_graph&quot;</span>, sg, vSubColor);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// recover color assignment according to the simplification level set previously </span></div>
<div class="line">        <span class="comment">// HIDE_SMALL_DEGREE needs to be recovered manually for density balancing </span></div>
<div class="line">        gs.recover(vMColor, mSubColor, mSimpl2Orig);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// recover colors for simplified vertices without balanced assignment </span></div>
<div class="line">        gs.recover_hide_small_degree(vMColor);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GraphType&gt;</div>
<div class="line"><span class="keywordtype">void</span> SDPColoringCsdp&lt;GraphType&gt;::coloring_algos(graph_type <span class="keyword">const</span>&amp; g, std::vector&lt;int8_t&gt;&amp; vColor)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">if</span> (boost::num_vertices(g) &lt;= max_backtrack_num_vertices)</div>
<div class="line">        coloring_by_backtrack(g, vColor);</div>
<div class="line">    <span class="keywordflow">else</span> </div>
<div class="line">        coloring_by_FM(g, vColor);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GraphType&gt;</div>
<div class="line"><span class="keywordtype">void</span> SDPColoringCsdp&lt;GraphType&gt;::coloring_by_backtrack(SDPColoringCsdp&lt;GraphType&gt;::graph_type <span class="keyword">const</span>&amp; mg, std::vector&lt;int8_t&gt;&amp; vColor)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// currently backtrack coloring is used </span></div>
<div class="line">    <span class="comment">// TO DO: add faster coloring approach like FM partition based </span></div>
<div class="line">    BacktrackColoring&lt;graph_type&gt; bc (mg);</div>
<div class="line">    bc.stitch_weight(1); <span class="comment">// already scaled in edge weights </span></div>
<div class="line">    bc.color_num(this-&gt;color_num());</div>
<div class="line">    bc();</div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0, ie = vColor.size(); i != ie; ++i)</div>
<div class="line">        vColor[i] = bc.color(i);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GraphType&gt;</div>
<div class="line"><span class="keywordtype">void</span> SDPColoringCsdp&lt;GraphType&gt;::coloring_by_FM(SDPColoringCsdp&lt;GraphType&gt;::graph_type <span class="keyword">const</span>&amp; mg, std::vector&lt;int8_t&gt;&amp; vColor)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <a class="code" href="a00087.html">limbo::algorithms::partition::FMMultiWay&lt;FMGainCalcType&gt;</a> fmp (FMGainCalcType(mg), boost::num_vertices(mg), this-&gt;color_num());</div>
<div class="line">    fmp.set_partitions(vColor.begin(), vColor.end());</div>
<div class="line">    fmp();</div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0, ie = vColor.size(); i != ie; ++i)</div>
<div class="line">        vColor[i] = fmp.partition(i);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GraphType&gt;</div>
<div class="line"><span class="keywordtype">void</span> SDPColoringCsdp&lt;GraphType&gt;::write_sdp_sol(std::string <span class="keyword">const</span>&amp; filename, <span class="keyword">struct</span> blockmatrix <span class="keyword">const</span>&amp; X)<span class="keyword"> const </span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// compute dimensions of matrix </span></div>
<div class="line">    uint32_t matrix_size = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (int32_t blk = 1; blk &lt;= X.nblocks; ++blk)</div>
<div class="line">        matrix_size += X.blocks[blk].blocksize;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// collect data from X and store to mSol </span></div>
<div class="line">    std::vector&lt;std::vector&lt;double&gt; &gt; mSol (matrix_size, std::vector&lt;double&gt;(matrix_size, 0.0));</div>
<div class="line">    <span class="comment">// as i and j starts from 1, set index_offset to -1 </span></div>
<div class="line">    int32_t index_offset = 0; </div>
<div class="line">    <span class="keywordflow">for</span> (int32_t blk = 1; blk &lt;= X.nblocks; ++blk)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">switch</span> (X.blocks[blk].blockcategory)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">case</span> DIAG:</div>
<div class="line">                <span class="keywordflow">for</span> (int32_t i = 1; i &lt;= X.blocks[blk].blocksize; ++i)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keywordtype">double</span> ent = X.blocks[blk].data.vec[i];</div>
<div class="line">                    <span class="keywordflow">if</span> (ent != 0.0)</div>
<div class="line">                        mSol[index_offset+i-1][index_offset+i-1] = ent;</div>
<div class="line">                };</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> MATRIX:</div>
<div class="line">                <span class="keywordflow">for</span> (int32_t i = 1; i &lt;= X.blocks[blk].blocksize; ++i)</div>
<div class="line">                    <span class="keywordflow">for</span> (int32_t j = i; j &lt;= X.blocks[blk].blocksize; ++j)</div>
<div class="line">                    {</div>
<div class="line">                        <span class="keywordtype">double</span> ent = X.blocks[blk].data.mat[ijtok(i, j, X.blocks[blk].blocksize)];</div>
<div class="line">                        <span class="keywordflow">if</span> (ent != 0.0)</div>
<div class="line">                            mSol[index_offset+i-1][index_offset+j-1] = ent;</div>
<div class="line">                    };</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> PACKEDMATRIX:</div>
<div class="line">            <span class="keywordflow">default</span>: <a class="code" href="a00341.html#aa5d7c58f57e3700b0de23ae54972bbca" title="assertion with message">assert_msg</a>(0, <span class="stringliteral">&quot;Invalid Block Type&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        index_offset += X.blocks[blk].blocksize; </div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// write to file </span></div>
<div class="line">    std::ofstream out (filename.c_str());</div>
<div class="line">    <a class="code" href="a00341.html#aa5d7c58f57e3700b0de23ae54972bbca" title="assertion with message">assert_msg</a>(out.good(), <span class="stringliteral">&quot;failed to open file &quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot; for write&quot;</span>);</div>
<div class="line">    <span class="keywordflow">for</span> (std::vector&lt;std::vector&lt;double&gt; &gt;::const_iterator it1 = mSol.begin(), it1e = mSol.end(); it1 != it1e; ++it1)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* prefix = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">        <span class="keywordflow">for</span> (std::vector&lt;double&gt;::const_iterator it2 = it1-&gt;begin(), it2e = it1-&gt;end(); it2 != it2e; ++it2)</div>
<div class="line">        {</div>
<div class="line">            out &lt;&lt; prefix &lt;&lt; *it2;</div>
<div class="line">            prefix = <span class="stringliteral">&quot;,&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        out &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    out.close();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GraphType&gt;</div>
<div class="line"><span class="keywordtype">void</span> SDPColoringCsdp&lt;GraphType&gt;::print_blockrec(<span class="keyword">const</span> <span class="keywordtype">char</span>* label, blockrec <span class="keyword">const</span>&amp; block)<span class="keyword"> const </span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    printf(<span class="stringliteral">&quot;%s&quot;</span>, label);</div>
<div class="line">    <span class="keywordflow">if</span> (block.blockcategory == MATRIX)</div>
<div class="line">    {</div>
<div class="line">        printf(<span class="stringliteral">&quot;[M]: &quot;</span>); <span class="comment">// show it is a matrix </span></div>
<div class="line">        <span class="keywordflow">for</span> (int32_t i = 0, ie = block.blocksize*block.blocksize; i != ie; ++i)</div>
<div class="line">            printf(<span class="stringliteral">&quot;%g &quot;</span>, block.data.mat[i]);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (block.blockcategory == DIAG)</div>
<div class="line">    {</div>
<div class="line">        printf(<span class="stringliteral">&quot;[V]: &quot;</span>); <span class="comment">// show it is a vector </span></div>
<div class="line">        <span class="keywordflow">for</span> (int32_t i = 0; i != block.blocksize; ++i)</div>
<div class="line">            printf(<span class="stringliteral">&quot;%g &quot;</span>, block.data.vec[i+1]);</div>
<div class="line">    }</div>
<div class="line">    printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">} <span class="comment">// namespace coloring</span></div>
<div class="line">} <span class="comment">// namespace algorithms</span></div>
<div class="line">} <span class="comment">// namespace limbo</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p> See documented version: <a class="el" href="a00363.html">test/algorithms/test_SDPColoring.cpp</a> </p>
<div class="fragment"><div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/graph/graphviz.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/graph/graph_utility.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/graph/adjacency_list.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/graph/undirected_graph.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00288.html" title="graph coloring algorithm based on semidefinite programming (SDP)">limbo/algorithms/coloring/SDPColoringCsdp.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/graph/erdos_renyi_generator.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/random/mersenne_twister.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/graph/random.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/graph/iteration_macros.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;boost/version.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#if BOOST_VERSION &lt;= 14601</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include &lt;boost/graph/detail/is_same.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include &lt;boost/type_traits/is_same.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="keyword">using</span> std::cout;</div>
<div class="line"><span class="keyword">using</span> std::endl;</div>
<div class="line"><span class="keyword">using</span> std::ifstream;</div>
<div class="line"><span class="keyword">using</span> std::ofstream;</div>
<div class="line"><span class="keyword">using</span> std::string;</div>
<div class="line"><span class="keyword">using</span> std::pair;</div>
<div class="line"><span class="keyword">using namespace </span>boost;</div>
<div class="line"></div>
<div class="line"><span class="comment">// do not use setS, it does not compile for subgraph</span></div>
<div class="line"><span class="comment">// do not use custom property tags, it does not compile for most utilities</span></div>
<div class="line"><span class="keyword">typedef</span> adjacency_list&lt;vecS, vecS, undirectedS, </div>
<div class="line">        property&lt;vertex_index_t, std::size_t, property&lt;vertex_color_t, int&gt; &gt;, </div>
<div class="line">        property&lt;edge_index_t, std::size_t, property&lt;edge_weight_t, double&gt; &gt;,</div>
<div class="line">        property&lt;graph_name_t, string&gt; &gt; graph_type;</div>
<div class="line"><span class="keyword">typedef</span> subgraph&lt;graph_type&gt; subgraph_type;</div>
<div class="line"><span class="keyword">typedef</span> property&lt;vertex_index_t, std::size_t&gt; VertexId;</div>
<div class="line"><span class="keyword">typedef</span> property&lt;edge_index_t, std::size_t&gt; EdgeID;</div>
<div class="line"><span class="keyword">typedef</span> graph_traits&lt;graph_type&gt;::vertex_descriptor vertex_descriptor; </div>
<div class="line"><span class="keyword">typedef</span> graph_traits&lt;graph_type&gt;::edge_descriptor edge_descriptor; </div>
<div class="line"><span class="keyword">typedef</span> property_map&lt;graph_type, edge_weight_t&gt;::type edge_weight_map_type;</div>
<div class="line"><span class="keyword">typedef</span> property_map&lt;graph_type, vertex_color_t&gt;::type vertex_color_map_type;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="a00361.html#a64ecec97bc4469a5414c0cae8ad15c7a">simple_graph</a>() </div>
<div class="line">{</div>
<div class="line">    graph_type g;</div>
<div class="line">    vertex_descriptor a = boost::add_vertex(g);</div>
<div class="line">    vertex_descriptor b = boost::add_vertex(g);</div>
<div class="line">    vertex_descriptor c = boost::add_vertex(g);</div>
<div class="line">    vertex_descriptor d = boost::add_vertex(g);</div>
<div class="line">    vertex_descriptor e = boost::add_vertex(g);</div>
<div class="line">    boost::add_edge(a, b, g);</div>
<div class="line">    boost::add_edge(a, c, g);</div>
<div class="line">    boost::add_edge(a, d, g);</div>
<div class="line">    boost::add_edge(a, e, g);</div>
<div class="line">    boost::add_edge(b, c, g);</div>
<div class="line">    boost::add_edge(b, e, g);</div>
<div class="line">    boost::add_edge(c, d, g);</div>
<div class="line">    boost::add_edge(d, e, g);</div>
<div class="line"></div>
<div class="line">    BOOST_AUTO(edge_weight_map, <span class="keyword">get</span>(edge_weight, g));</div>
<div class="line">    graph_traits&lt;graph_type&gt;::edge_iterator eit, eit_end;</div>
<div class="line">    <span class="keywordflow">for</span> (tie(eit, eit_end) = edges(g); eit != eit_end; ++eit)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (source(*eit, g) != a || target(*eit, g) != d)</div>
<div class="line">            edge_weight_map[*eit] = 1;</div>
<div class="line">        <span class="keywordflow">else</span> </div>
<div class="line">            edge_weight_map[*eit] = -1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//test relaxed LP based coloring</span></div>
<div class="line">    <a class="code" href="a00223.html">limbo::algorithms::coloring::SDPColoringCsdp&lt;graph_type&gt;</a> lc (g); </div>
<div class="line">    lc.stitch_weight(0.1);</div>
<div class="line">    <span class="comment">// THREE or FOUR </span></div>
<div class="line">    lc.color_num(<a class="code" href="a00223.html">limbo::algorithms::coloring::SDPColoringCsdp&lt;graph_type&gt;::THREE</a>);</div>
<div class="line">    <span class="keywordflow">return</span> lc();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="a00361.html#aaef48baf5127c418e61732f2b73ce33a">random_graph</a>() </div>
<div class="line">{</div>
<div class="line">    mt19937 gen;</div>
<div class="line">    graph_type g;</div>
<div class="line">    <span class="keywordtype">int</span> N = 40;</div>
<div class="line">    std::vector&lt;vertex_descriptor&gt; vertex_set;</div>
<div class="line">    std::vector&lt; std::pair&lt;vertex_descriptor, vertex_descriptor&gt; &gt; edge_set;</div>
<div class="line">    generate_random_graph(g, N, N * 2, gen,</div>
<div class="line">            std::back_inserter(vertex_set),</div>
<div class="line">            std::back_inserter(edge_set));</div>
<div class="line">    BOOST_AUTO(edge_weight_map, <span class="keyword">get</span>(edge_weight, g));</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; </div>
<div class="line">    graph_traits&lt;graph_type&gt;::edge_iterator eit, eit_end;</div>
<div class="line">    <span class="keywordflow">for</span> (tie(eit, eit_end) = edges(g); eit != eit_end; ++eit, ++i)</div>
<div class="line">    {</div>
<div class="line"><span class="preprocessor">#if 1</span></div>
<div class="line"><span class="preprocessor"></span>        <span class="keywordflow">if</span> (i%10 == 0) <span class="comment">// generate stitch </span></div>
<div class="line">            edge_weight_map[*eit] = -1;</div>
<div class="line">        <span class="keywordflow">else</span> <span class="comment">// generate conflict </span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>            edge_weight_map[*eit] = 1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//test relaxed LP based coloring</span></div>
<div class="line">    <a class="code" href="a00223.html">limbo::algorithms::coloring::SDPColoringCsdp&lt;graph_type&gt;</a> lc (g); </div>
<div class="line">    lc.stitch_weight(0.1);</div>
<div class="line">    <span class="comment">// THREE or FOUR </span></div>
<div class="line">    lc.color_num(<a class="code" href="a00223.html">limbo::algorithms::coloring::SDPColoringCsdp&lt;graph_type&gt;::THREE</a>);</div>
<div class="line">    <span class="keywordflow">return</span> lc();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="a00361.html#a938db4401587853297b329cb2d7d6237">real_graph</a>(<span class="keywordtype">string</span> <span class="keyword">const</span>&amp; filename)</div>
<div class="line">{</div>
<div class="line">    ifstream in (filename.c_str());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// the graphviz reader in boost cannot specify vertex_index_t</span></div>
<div class="line">    <span class="comment">// I have to create a temporary graph and then construct the real graph </span></div>
<div class="line">    <span class="keyword">typedef</span> adjacency_list&lt;vecS, vecS, undirectedS, </div>
<div class="line">            property&lt;vertex_index_t, std::size_t, property&lt;vertex_color_t, int, property&lt;vertex_name_t, std::size_t&gt; &gt; &gt;, </div>
<div class="line">            property&lt;edge_index_t, std::size_t, property&lt;edge_weight_t, int&gt; &gt;,</div>
<div class="line">            property&lt;graph_name_t, string&gt; &gt; tmp_graph_type;</div>
<div class="line">    tmp_graph_type tmpg;</div>
<div class="line">    dynamic_properties tmpdp;</div>
<div class="line">    tmpdp.property(<span class="stringliteral">&quot;node_id&quot;</span>, <span class="keyword">get</span>(vertex_name, tmpg));</div>
<div class="line">    tmpdp.property(<span class="stringliteral">&quot;label&quot;</span>, <span class="keyword">get</span>(vertex_name, tmpg));</div>
<div class="line">    tmpdp.property(<span class="stringliteral">&quot;weight&quot;</span>, <span class="keyword">get</span>(edge_weight, tmpg));</div>
<div class="line">    tmpdp.property(<span class="stringliteral">&quot;label&quot;</span>, <span class="keyword">get</span>(edge_weight, tmpg));</div>
<div class="line">    assert(read_graphviz(in, tmpg, tmpdp, <span class="stringliteral">&quot;node_id&quot;</span>));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// real graph </span></div>
<div class="line">    graph_type g (num_vertices(tmpg));</div>
<div class="line">    graph_traits&lt;tmp_graph_type&gt;::vertex_iterator vit, vit_end;</div>
<div class="line">    <span class="keywordflow">for</span> (tie(vit, vit_end) = vertices(tmpg); vit != vit_end; ++vit)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">size_t</span> name  = <span class="keyword">get</span>(vertex_name, tmpg, *vit);</div>
<div class="line">        <span class="keywordtype">int</span> color = <span class="keyword">get</span>(vertex_color, tmpg, *vit);</div>
<div class="line">        put(vertex_color, g, (vertex_descriptor)name, color);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    graph_traits&lt;tmp_graph_type&gt;::edge_iterator eit, eit_end;</div>
<div class="line">    <span class="keywordflow">for</span> (tie(eit, eit_end) = edges(tmpg); eit != eit_end; ++eit)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">size_t</span> s_name = <span class="keyword">get</span>(vertex_name, tmpg, source(*eit, tmpg));</div>
<div class="line">        <span class="keywordtype">size_t</span> t_name = <span class="keyword">get</span>(vertex_name, tmpg, target(*eit, tmpg));</div>
<div class="line">        pair&lt;edge_descriptor, bool&gt; pe = add_edge(s_name, t_name, g);</div>
<div class="line">        assert(pe.second);</div>
<div class="line">        <span class="keywordtype">int</span> weight = <span class="keyword">get</span>(edge_weight, g, *eit);</div>
<div class="line">        put(edge_weight, g, pe.first, weight);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef DEBUG_SDPCOLORING</span></div>
<div class="line"><span class="preprocessor"></span>    dynamic_properties dp;</div>
<div class="line">    dp.property(<span class="stringliteral">&quot;id&quot;</span>, <span class="keyword">get</span>(vertex_index, g));</div>
<div class="line">    dp.property(<span class="stringliteral">&quot;node_id&quot;</span>, <span class="keyword">get</span>(vertex_index, g));</div>
<div class="line">    dp.property(<span class="stringliteral">&quot;label&quot;</span>, <span class="keyword">get</span>(vertex_index, g));</div>
<div class="line">    dp.property(<span class="stringliteral">&quot;weight&quot;</span>, <span class="keyword">get</span>(edge_weight, g));</div>
<div class="line">    dp.property(<span class="stringliteral">&quot;label&quot;</span>, <span class="keyword">get</span>(edge_weight, g));</div>
<div class="line">    ofstream out (<span class="stringliteral">&quot;graph_init.gv&quot;</span>);</div>
<div class="line">    write_graphviz_dp(out, g, dp, <span class="keywordtype">string</span>(<span class="stringliteral">&quot;id&quot;</span>));</div>
<div class="line">    out.close();</div>
<div class="line">    system(<span class="stringliteral">&quot;dot -Tpdf graph_init.gv -o graph_init.pdf&quot;</span>);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="comment">//test relaxed LP based coloring</span></div>
<div class="line">    <a class="code" href="a00223.html">limbo::algorithms::coloring::SDPColoringCsdp&lt;graph_type&gt;</a> lc (g); </div>
<div class="line">    lc.stitch_weight(0.1);</div>
<div class="line">    <span class="comment">// THREE or FOUR </span></div>
<div class="line">    lc.color_num(<a class="code" href="a00223.html">limbo::algorithms::coloring::SDPColoringCsdp&lt;graph_type&gt;::THREE</a>);</div>
<div class="line">    <span class="keywordtype">double</span> cost = lc();</div>
<div class="line"></div>
<div class="line">    in.close();</div>
<div class="line">    <span class="keywordflow">return</span> cost;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="a00357.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">double</span> cost;</div>
<div class="line">    <span class="keywordflow">if</span> (argc &lt; 2)</div>
<div class="line">    {</div>
<div class="line">        cost = <a class="code" href="a00361.html#a64ecec97bc4469a5414c0cae8ad15c7a">simple_graph</a>();</div>
<div class="line">        <span class="comment">//cost = random_graph();</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> cost = <a class="code" href="a00361.html#a938db4401587853297b329cb2d7d6237">real_graph</a>(argv[1]);</div>
<div class="line"></div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;cost = &quot;</span> &lt;&lt; cost &lt;&lt; endl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Compiling and running commands (assuming LIMBO_DIR, BOOST_DIR and LEMON_DIR are well defined). <a class="el" href="a00013.html">Limbo.Parsers.LpParser</a> is required for <a class="el" href="a00154.html">limbo::solvers::lpmcf::LpDualMcf</a> to read input files in .lp format. </p>
<pre class="fragment">g++ -o test_lpmcf compare.cpp -I $LIMBO_DIR/include -I $BOOST_DIR/include -I $LEMON_DIR/include -L $LEMON_DIR/lib -lemon -L $LIMBO_DIR/lib -llpparser
# test: min-cost flow for network graph 
./test_lpmcf benchmarks/graph.lgf 
</pre><h2><a class="anchor" id="Solvers_Examples_GurobiApi"></a>
Gurobi API</h2>
<p>A generalized API to solve problem described by <a class="el" href="a00149.html">limbo::solvers::LinearModel</a> with <a href="https://www.gurobi.com" title="Gurobi">Gurobi</a> solver.</p>
<p>See documented version: <a class="el" href="a00383.html">test/solvers/test_GurobiApi.cpp</a> </p>
<div class="fragment"><div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00347.html" title="Gurobi API by writing out problem file in LP format and read solution. Consider the file IO overhead ...">limbo/solvers/api/GurobiApi.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="a00357.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ILP model </span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="a00149.html" title="model to describe an optimization problem">limbo::solvers::LinearModel&lt;double, long&gt;</a> model_type; </div>
<div class="line">    model_type optModel; </div>
<div class="line"></div>
<div class="line">    <span class="comment">// create variables </span></div>
<div class="line">    model_type::variable_type var1 = optModel.<a class="code" href="a00149.html#a77f761932ea800a66075c1df656535e8" title="add one variable">addVariable</a>(0, 1, <a class="code" href="a00409.html#a500190a99a5762b6aa25aec1230479f0a1bce99917ec61f5352e27e0ec986d931" title="floating point number">limbo::solvers::CONTINUOUS</a>, <span class="stringliteral">&quot;x1&quot;</span>);</div>
<div class="line">    model_type::variable_type var2 = optModel.addVariable(0, 1, <a class="code" href="a00409.html#a500190a99a5762b6aa25aec1230479f0a1bce99917ec61f5352e27e0ec986d931" title="floating point number">limbo::solvers::CONTINUOUS</a>, <span class="stringliteral">&quot;x2&quot;</span>);</div>
<div class="line">    model_type::variable_type var3 = optModel.addVariable(0, 1, <a class="code" href="a00409.html#a500190a99a5762b6aa25aec1230479f0a1bce99917ec61f5352e27e0ec986d931" title="floating point number">limbo::solvers::CONTINUOUS</a>, <span class="stringliteral">&quot;x3&quot;</span>);</div>
<div class="line">    model_type::variable_type var4 = optModel.addVariable(0, 1, <a class="code" href="a00409.html#a500190a99a5762b6aa25aec1230479f0a1bce99917ec61f5352e27e0ec986d931" title="floating point number">limbo::solvers::CONTINUOUS</a>, <span class="stringliteral">&quot;x4&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// create objective</span></div>
<div class="line">    optModel.setObjective(var1+var2+var3+var4); </div>
<div class="line">    optModel.setOptimizeType(<a class="code" href="a00409.html#a500190a99a5762b6aa25aec1230479f0a79885399adf94fecd8e9ade4985dd2d7" title="minimize objective">limbo::solvers::MIN</a>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// create constraints </span></div>
<div class="line">    optModel.addConstraint(var1 - var2 &gt;= 0.5, <span class="stringliteral">&quot;c1&quot;</span>); </div>
<div class="line">    optModel.addConstraint(var4 - var3 &gt;= 0.1, <span class="stringliteral">&quot;c2&quot;</span>); </div>
<div class="line">    optModel.addConstraint(var2 - var3 &gt;= 0.2, <span class="stringliteral">&quot;c3&quot;</span>); </div>
<div class="line"></div>
<div class="line">    <span class="comment">// solve by Gurobi </span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="a00127.html" title="Gurobi API with limbo::solvers::LinearModel.">limbo::solvers::GurobiLinearApi&lt;model_type::coefficient_value_type, model_type::variable_value_type&gt;</a> solver_type; </div>
<div class="line">    solver_type solver (&amp;optModel); </div>
<div class="line">    <a class="code" href="a00128.html" title="Base class for custom Gurobi parameters.">limbo::solvers::GurobiParameters</a> gurobiParams; </div>
<div class="line">    gurobiParams.<a class="code" href="a00128.html#a8e06cfed9fd9a5a22a01c75f86192c10" title="set number of threads">setNumThreads</a>(1);</div>
<div class="line">    gurobiParams.<a class="code" href="a00128.html#aad7e339df9aacdbddcfd55127b184902" title="set output flag">setOutputFlag</a>(1); </div>
<div class="line"></div>
<div class="line">    <a class="code" href="a00409.html#a500190a99a5762b6aa25aec1230479f0" title="Some enums used in solver.">limbo::solvers::SolverProperty</a> optStatus = solver(&amp;gurobiParams); </div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;optStatus = &quot;</span> &lt;&lt; optStatus &lt;&lt; std::endl; </div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0; </div>
<div class="line">}</div>
</div><!-- fragment --><p>Compiling and running commands (assuming LIMBO_DIR, and GUROBI_HOME are well defined). </p>
<pre class="fragment">g++ -o test_GurobiApi test_GurobiApi.cpp -I $LIMBO_DIR/include -I $GUROBI_HOME/include -L $GUROBI_HOME/lib -lgurobi_c++ -lgurobi60 
# test Gurobi API for linear programming problem 
./test_GurobiApi
</pre><p>Output </p>
<pre class="fragment">Optimize a model with 3 rows, 4 columns and 6 nonzeros
Coefficient statistics:
  Matrix range    [1e+00, 1e+00]
  Objective range [1e+00, 1e+00]
  Bounds range    [1e+00, 1e+00]
  RHS range       [1e-01, 5e-01]
Presolve removed 3 rows and 4 columns
Presolve time: 0.00s
Presolve: All rows and columns removed
Iteration    Objective       Primal Inf.    Dual Inf.      Time
       0    1.0000000e+00   0.000000e+00   0.000000e+00      0s

Solved in 0 iterations and 0.00 seconds
Optimal objective  1.000000000e+00
optStatus = 5
</pre><h2><a class="anchor" id="Solvers_Examples_All"></a>
All Examples</h2>
<p>Possible dependencies: <a href="http://www.boost.org">Boost</a>, <a href="https://lemon.cs.elte.hu">Lemon</a>.</p>
<ul>
<li><a class="el" href="a00381.html">test/solvers/lpmcf/test_lpmcf.cpp</a></li>
<li><a class="el" href="a00385.html">test/solvers/test_solvers.cpp</a></li>
<li><a class="el" href="a00384.html">test/solvers/test_MultiKnapsackLagRelax.cpp</a></li>
<li><a class="el" href="a00382.html">test/solvers/test_DualMinCostFlow.cpp</a></li>
<li><a class="el" href="a00383.html">test/solvers/test_GurobiApi.cpp</a></li>
</ul>
<h1><a class="anchor" id="Solvers_References"></a>
References</h1>
<ul>
<li><a class="el" href="a00349.html">limbo/solvers/lpmcf/Lgf.h</a></li>
<li><a class="el" href="a00350.html">limbo/solvers/lpmcf/LpDualMcf.h</a></li>
<li><a class="el" href="a00346.html">limbo/solvers/api/CsdpEasySdpApi.h</a></li>
<li><a class="el" href="a00347.html">limbo/solvers/api/GurobiApi.h</a></li>
<li><a class="el" href="a00351.html">limbo/solvers/MultiKnapsackLagRelax.h</a></li>
<li><a class="el" href="a00348.html">limbo/solvers/DualMinCostFlow.h</a> </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 16 2017 16:28:49 for Limbo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
